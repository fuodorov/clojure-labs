# Лабораторная работа 1: Базовые операции над структурами данных

## Общее условие

Задан набор символов и число n. Реализованы функции, которые возвращают список всех строк длины n, состоящих из этих символов и не содержащих двух одинаковых символов, идущих подряд.

### Пример
Для символов 'a', 'b', 'c' и n=2 результат: `("ab" "ac" "ba" "bc" "ca" "cb")` (с точностью до перестановки).

## Задачи

### Задача 1.1: Элементарные операции и рекурсия
**Файл:** `task_1.clj`

**Описание:** Решение использует только элементарные операции над последовательностями (`cons`, `first`, `rest`, `concat`) и рекурсию.

**Основная функция:** `generate-strings`

**Принцип работы:**
1. Рекурсивно строит строки заданной длины
2. Для каждого символа проверяет, не совпадает ли он с последним символом текущей строки
3. Если не совпадает - добавляет символ и продолжает рекурсию
4. Базовый случай: когда длина достигнута, возвращает текущую строку

**Запуск:**
```bash
clojure lab_1/task_1.clj
```

---

### Задача 1.2: Хвостовая рекурсия
**Файл:** `task_2.clj`

**Описание:** Переписанное решение задачи 1.1 с использованием хвостовой рекурсии (tail recursion) для оптимизации использования стека.

**Основная функция:** `generate-strings-tail`

**Принцип работы:**
1. Использует аккумулятор для накопления результатов
2. Все рекурсивные вызовы находятся в хвостовой позиции
3. Использует `recur` для оптимизации хвостовых вызовов
4. Результат формируется в обратном порядке из-за особенностей накопления

**Преимущества:**
- Не расходует память стека при глубокой рекурсии
- Может обрабатывать большие значения n без переполнения стека

**Запуск:**
```bash
clojure lab_1/task_2.clj
```

---

### Задача 1.3: Реализация my-map и my-filter через reduce
**Файл:** `task_3.clj`

**Описание:** Реализованы аналоги стандартных функций `map` и `filter` с использованием только `reduce` и базовых операций над списками.

**Функции:**
- `my-map` - применяет функцию к каждому элементу списка
- `my-filter` - фильтрует элементы по предикату

**Принцип работы:**
1. `my-map`: использует `reduce` с аккумулятором, добавляя преобразованные элементы
2. `my-filter`: использует `reduce`, добавляя только элементы, удовлетворяющие предикату

**Тестирование:**
- Сравнение с стандартными `map` и `filter`
- Тесты на различных данных
- Комбинированное использование

**Запуск:**
```bash
clojure lab_1/task_3.clj
```

---

### Задача 1.4: Решение через функционалы map/reduce/filter
**Файл:** `task_4.clj`

**Описание:** Решение основной задачи с использованием функционалов высшего порядка: `map`, `reduce`, `filter`.

**Основная функция:** `generate-strings-functional`

**Принцип работы:**
1. Использует `map` для добавления символов к строкам
2. Использует `filter` для отсеивания строк с одинаковыми символами подряд
3. Использует `reduce` для объединения результатов по всем символам
4. Более декларативный и функциональный стиль по сравнению с задачей 1.1

**Преимущества:**
- Более читаемый и понятный код
- Следует функциональной парадигме
- Легко расширяется и модифицируется

**Запуск:**
```bash
clojure lab_1/task_4.clj
```

---

## Запуск всех задач

```bash
# Из корневой директории проекта
clojure lab_1/task_1.clj
clojure lab_1/task_2.clj
clojure lab_1/task_3.clj
clojure lab_1/task_4.clj
```

## Примеры результатов

Для `symbols=["a" "b" "c"]` и `n=2`:
```
("ab" "ac" "ba" "bc" "ca" "cb")
```

Для `symbols=["a" "b" "c"]` и `n=3`:
```
("aba" "abc" "aca" "acb" "bab" "bac" "bca" "bcb" "cab" "cac" "cba" "cbc")
```

Для `symbols=["a" "b"]` и `n=4`:
```
("abab" "baba")
```

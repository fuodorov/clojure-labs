# Лабораторная работа 2: Численное интегрирование

## Общее условие

Реализовать функцию (оператор), принимающую аргументом функцию от одной переменной `f` и возвращающую функцию одной переменной, вычисляющую (численно) выражение:

$$\int\limits_0^x f(t)\mathrm{d}t$$

**Метод:** Метод трапеций с постоянным шагом

**Особенность:** При оптимизации исходим из того, что полученная первообразная будет использоваться для построения графика (т.е. вызываться многократно в разных точках).

## Задачи

### Задача 2.1: Оптимизация с помощью мемоизации
**Файл:** `task_1.clj`

**Описание:** Реализует численное интегрирование с кэшированием (мемоизацией) уже вычисленных значений.

**Основная функция:** `integrate-memoized`

**Принцип работы:**
1. Вычисляет интеграл методом трапеций с шагом 0.001
2. Сохраняет результаты в атоме (изменяемом состоянии)
3. При повторном вызове с тем же аргументом возвращает закэшированное значение
4. Значительно ускоряет повторные вычисления

**Метод трапеций:**
```
Интеграл ≈ Σ (f(x_i) + f(x_{i+1})) / 2 * Δx
```

**Преимущества мемоизации:**
- Первый вызов: ~27 мс
- Повторный вызов: ~0.04 мс (в ~675 раз быстрее!)

**Тестирование:**
- f(x) = x → F(x) ≈ x²/2
- f(x) = x² → F(x) ≈ x³/3
- f(x) = 1 → F(x) ≈ x

**Запуск:**
```bash
clojure lab_2/task_1.clj
```

**Пример использования:**
```clojure
(let [f (fn [x] (* x x))  ; f(x) = x²
      F (integrate-memoized f)]
  (F 2.0))  ; => 2.6667 ≈ 8/3
```

---

### Задача 2.2: Оптимизация с помощью бесконечной последовательности
**Файл:** `task_2.clj`

**Описание:** Реализует численное интегрирование с использованием ленивой бесконечной последовательности частичных решений.

**Основная функция:** `integrate-lazy`

**Принцип работы:**
1. Создаёт ленивую бесконечную последовательность частичных интегралов
2. Каждый элемент i содержит интеграл от 0 до i*step
3. При запросе значения F(x) берётся соответствующий элемент последовательности
4. Элементы вычисляются лениво (только когда нужны)
5. Уже вычисленные элементы кэшируются

**Преимущества ленивых последовательностей:**
- Эффективно для построения графиков (многократные вызовы в порядке возрастания)
- Повторное использование предыдущих вычислений
- Естественная мемоизация через структуру данных
- Работает как бесконечный "поток" частичных решений

**Особенность:**
Каждый следующий элемент последовательности строится на основе предыдущего:
```
integral[i] = integral[i-1] + trapezoid_area[i-1, i]
```

**Тестирование:**
- f(x) = x → F(x) ≈ x²/2
- f(x) = x² → F(x) ≈ x³/3
- f(x) = 1 → F(x) ≈ x
- Построение графика (множественные вызовы)

**Запуск:**
```bash
clojure lab_2/task_2.clj
```

**Пример использования:**
```clojure
(let [f (fn [x] x)  ; f(x) = x
      F (integrate-lazy f)
      points [1.0 2.0 3.0 4.0 5.0]]
  (map F points))  ; Эффективно при последовательном вызове
```

---

## Сравнение подходов

### Мемоизация (2.1)
**Плюсы:**
- Простая реализация
- Очень быстрые повторные вызовы с теми же аргументами
- Подходит для случайного доступа

**Минусы:**
- Каждое новое значение вычисляется с нуля
- Не использует результаты предыдущих вычислений

### Ленивая последовательность (2.2)
**Плюсы:**
- Использует предыдущие вычисления
- Эффективна для построения графиков (возрастающие x)
- Естественная структура для инкрементальных вычислений
- Функциональный подход

**Минусы:**
- Более сложная реализация
- Менее эффективна для случайного доступа к далёким точкам

---

## Метод трапеций

Численное интегрирование методом трапеций разбивает область интегрирования на n отрезков и аппроксимирует площадь под кривой трапециями:

```
∫[a,b] f(x)dx ≈ Σ[i=0 to n-1] (f(x_i) + f(x_{i+1})) / 2 * Δx
```

где:
- Δx = (b - a) / n - ширина каждого отрезка
- x_i = a + i * Δx - точки разбиения

**Точность:** O(Δx²) - квадратичная зависимость от шага

В нашей реализации:
- a = 0
- b = x (аргумент функции)
- step = 0.001 (постоянный шаг)

---

## Запуск всех задач

```bash
# Из корневой директории проекта
clojure lab_2/task_1.clj
clojure lab_2/task_2.clj
```

## Примеры результатов

### f(x) = x (первообразная x²/2)
```
F(2) = 2.0000      (ожидается 2.0)
F(4) = 8.0000      (ожидается 8.0)
F(10) = 50.0000    (ожидается 50.0)
```

### f(x) = x² (первообразная x³/3)
```
F(2) = 2.6667      (ожидается 2.6667)
F(3) = 9.0000      (ожидается 9.0)
F(5) = 41.6667     (ожидается 41.6667)
```

### f(x) = 1 (первообразная x)
```
F(5) = 5.0000      (ожидается 5.0)
F(10) = 10.0000    (ожидается 10.0)
```

## Производительность

### Мемоизация (задача 2.1)
```
Первый вызов F(100):     ~27 мс
Повторный вызов F(100):  ~0.04 мс  (ускорение в 675 раз!)
Новое значение F(200):   ~3.5 мс
```

### Ленивая последовательность (задача 2.2)
```
Построение графика (8 точек): ~12 мс
Последовательные вызовы (10 точек): ~21 мс
```

Ленивая последовательность особенно эффективна при построении графиков, где точки идут в порядке возрастания x.
